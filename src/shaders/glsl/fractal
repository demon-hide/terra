#line 2
uniform sampler2DArray heights;
uniform sampler2DArray slopes;
uniform sampler2D noise;
uniform float noiseWavelength;
uniform int numLayers;

const int MAX_LAYERS = 16;

struct Layer {
	vec2 center;
	vec2 size;
};
uniform layersBuffer {
	Layer layers[MAX_LAYERS];
};

vec2 compute_texcoord(vec2 pos, int layer) {
	return vec2(0.5) + (pos - layers[layer].center) / layers[layer].size;
}

/// Uses a fractal to refine the height and slope sourced from the course texture.
void compute_height_and_slope(vec2 pos, vec2 texCoord, out float height, out vec2 slope) {
	int layer = numLayers - 1;
	while(layer > 0 &&
		  any(greaterThan(abs(pos - layers[layer].center), layers[layer].size * 0.5))) {
		layer -= 1;
	}

	vec2 t = compute_texcoord(pos, layer);
	height = texture(heights, vec3(t, layer)).r;
	slope = texture(slopes, vec3(t, layer)).xy;

	float fadeDistance = 0.01;
	float edgeDistance = 0.5 - max(abs(t.x - 0.5), abs(t.y - 0.5));
	if(edgeDistance < fadeDistance && layer > 0) {
		float fade = 1.0 - edgeDistance / fadeDistance;

		vec2 t = compute_texcoord(pos, layer - 1);
		height = mix(height, texture(heights, vec3(t, layer - 1)).r, fade);
		slope = mix(slope, texture(slopes, vec3(t, layer - 1)).xy, fade);
	}
}
